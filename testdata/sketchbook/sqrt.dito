# ---------------------------------------------
# These capabilities are not implemented yet.
# ---------------------------------------------

# Full dito function. type specifier is arbitary
# but coerces the results to me the critera.


# Calculate the sqrt of a number to an acuracy of
# delta using newtons method.
func newton_sqrt(x: int, delta: 1/128) -> (float) {
    z := delta
    for (x - z**2) >= delta {
        z = z - (z**2 - x) / (2 * x)
    }
    return z
}


newton_sqrt := func(z, x, delta) -> (
    z if (x - z**2) < delta else
    newton_sqrt((z - (z**2-x) / (2*x), x, delta))
)

fn newton_sqrt(x: int, delta=1/128) {
    fn d(z: Float, x: Float) -> (z**2 - x)
    fn grad(z: Float, x: Float) -> (z**2 - x) / (2 * x)
} -> ((z = z - grad(z, x) for diff(z, x) >= delta))


# Shorthand functinons / lambda functions.

func sqrt(x) -> (x**0.5)

func hello(x_ray: int, yankee: str, zebra: float)
    -> (alpha: int, beta: int, charlie: int, delta: int) {
    "return some crazy shite or eat shite"
    print("hello")
}

sqrt(25) + sqrt2(25)

def Point: # {
    x: int,
    y: int
    hypot: func() -> sqrt(x**2 + y**2)
# }

p = Point(x: 100, y: 100)

p.hypot()
